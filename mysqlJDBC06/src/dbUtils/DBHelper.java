package dbUtils;

import java.lang.reflect.Field;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;


/**
 * sql 封装
 * @author Administrator
 *
 */
@SuppressWarnings("rawtypes")
public class DBHelper {
	
	/**
	 * 主要进行sql语句执行，这里是自动提交事务 并且已经关闭了资源
	 * 注意：几个占位符就需要传入几个参数
	 * @param sql 传进来的sql语句  类似于：insert into table (tableName) values (?)
	 * @param params 参数   类似与：new Object []{"参数1","参数2","参数3","参数4","参数5",...}
	 * @param autoGeneratedkeys  Boolean类型的   false就是不需要返回主键，true就是需要返回主键
	 * @return 返回的是一个主键  如果没有就返回null
	 */
	public static Object executeUpdateSql(String sql,Object [] params,Boolean autoGeneratedkeys){
		Connection conn = null;
		PreparedStatement ps = null;
		Integer key = null;
		//编译sql
		try {
			// 连接数据库
			conn = DBUtils.getConnection();
			
			if(autoGeneratedkeys){
				ps = conn.prepareStatement(sql,Statement.RETURN_GENERATED_KEYS);
			}else{
				ps = conn.prepareStatement(sql);
			}
			
			for (int i = 0; i < params.length; i++) {
				ps.setObject(i+1, params[i]);
			}
			// 执行SQL语句
			ps.executeUpdate();
			
			if(autoGeneratedkeys){
				ResultSet keys = ps.getGeneratedKeys();
				while(keys.next()){
					key = keys.getInt(1);
				}
			}
			
		} catch (SQLException e) {
			e.printStackTrace();
		}finally{
			DBUtils.close(conn, ps, null);
		}
		
		return key;
		
	}
	
	
	/**
	 * 主要进行sql语句执行，这里是自动提交事务 并且已经关闭了资源
	 * 注意：几个占位符就需要传入几个参数
	 * @param sql 传进来的sql语句  类似于：insert into table (tableName) values (?)
	 * @param params 参数   类似与：new Object []{"参数1","参数2","参数3","参数4","参数5",...}
	 */
	public static void executeUpdateSql(String sql,Object [] params){
		DBHelper.executeUpdateSql(sql, params, false);
	}
	
	
	/**
	 * 
	 * @param sqlAndParams   Map<String, Object[]>  key 对应的是sql   value对应的是上sql所对应的参数
	 */
	public static void executeUpdateSqls(Map<String, Object[]> sqlAndParams){
		Connection conn = null;
		PreparedStatement ps = null;
		//编译sql
		try {
			// 连接数据库
			conn = DBUtils.getConnection();
			
			conn.setAutoCommit(false);
			
			Set<Entry<String, Object[]>> entrySet = sqlAndParams.entrySet();
			
			for (Entry<String, Object[]> entry : entrySet) {
				String sql = entry.getKey();
				Object[] params = entry.getValue();
				
				ps = conn.prepareStatement(sql);
				
				for (int i = 0; i < params.length; i++) {
					ps.setObject(i+1, params[i]);
				}
				// 执行SQL语句
				ps.executeUpdate();
			}
			
			conn.commit();
		} catch (SQLException e) {
			e.printStackTrace();
			try {
				conn.rollback();
				System.out.println("sql执行出错！！ 已经回滚！");
			} catch (SQLException e1) {
				e1.printStackTrace();
			}
		}finally{
			DBUtils.close(conn, ps, null);
		}
	}
	
	
	/**
	 * 需要手动管控事物 ，也是就说数据库连接需要当做参数传入进来
	 * @param sql 传进来的sql语句  类似于：insert into table (tableName) values (?)
	 * @param params 参数   类似与：new Object []{"参数1","参数2","参数3","参数4","参数5",...}
	 * @param autoGeneratedkeys  Boolean类型的   false就是不需要返回主键，true就是需要返回主键
	 * @return 返回的是一个主键  如果没有就返回null
	 * @param conn  数据库连接   java.sql.Connection 对像
	 * @return  返回的 insert sql 执行后往数据库插入的数据的 主键
	 * @throws SQLException  抛出异常   谁调用的我我就抛给谁，注意需要铺货异常。
	 */
	public static Object executeSql(String sql,Object [] params,Boolean autoGeneratedkeys,Connection conn) throws SQLException{
		PreparedStatement ps = null;
		Integer key = null;
			
		if(autoGeneratedkeys){
			ps = conn.prepareStatement(sql,Statement.RETURN_GENERATED_KEYS);
		}else{
			ps = conn.prepareStatement(sql);
		}
		
		for (int i = 0; i < params.length; i++) {
			ps.setObject(i+1, params[i]);
		}
		// 执行SQL语句
		ps.executeUpdate();
		
		if(autoGeneratedkeys){
			ResultSet keys = ps.getGeneratedKeys();
			while(keys.next()){
				key = keys.getInt(1);
			}
		}
		
		return key;
		
	}
	
	public static void executeSql(String sql,Object [] params,Connection conn) throws SQLException{
		DBHelper.executeSql(sql, params, conn);
	}

	
	/**
	 	empName  empId    empAge
		zhangsan    1       20
		lisi        2       55
	 * @param sql  
	 * @param params 
	 * @param firstRow  分页  从第几行开始
	 * @param pageCount 每页显示多少条
	 * @return List<Map<String, Object>>
	 */
	public static List<Map<String, Object>> getDatas(String sql,Object[] params,Integer firstRow,Integer pageCount){
		Connection conn = null;
		PreparedStatement ps = null;
		ResultSet rs = null;
		List<Map<String, Object>> dataList = new ArrayList<Map<String, Object>>();
		
		if(null != firstRow && null != pageCount && firstRow >= 0 && pageCount >= 1){
			sql = sql + " limit " + firstRow + "," + pageCount;
		}
		//编译sql
		try {
			// 连接数据库
			conn = DBUtils.getConnection();
			
			ps = conn.prepareStatement(sql);
			
			for (int i = 0; i < params.length; i++) {
				ps.setObject(i+1, params[i]);
			}
			
			// 取到的元数据 （列名）
			ResultSetMetaData metaData = ps.getMetaData();
			int columnCount = metaData.getColumnCount();
			
			rs = ps.executeQuery();
			//"select empId,empName,password,empAge from employee where empId = ? and empName = ? group by empName HAVING AVG(empAge) > ? limit ?,?  ";
			while(rs.next()){
				for (int i = 1; i <= columnCount; i++) {
					
					// 保存列名和列名对应的value值
					Map<String , Object> dataMap = new HashMap<String, Object>();
					
					//  取到的是数据库的列名
					//String columnName = metaData.getColumnName(i);
					// 取到的是sql中的别名
					String columnLabel = metaData.getColumnLabel(i);
					Object obj = rs.getObject(i);
					
					dataMap.put(columnLabel, obj);
					
					dataList.add(dataMap);
					//System.out.println(columnName  + " : " + columnLabel + " : " + obj);
				}
			}
			
		} catch (SQLException e) {
			e.printStackTrace();
		}finally{
			DBUtils.close(conn, ps, rs);
		}
		return dataList;
	}
	
	
	public static List<Map<String, Object>> getDatas(String sql,Object[] params){
		return DBHelper.getDatas(sql, params, null, null);
	}
	
	
	
	
	/**
	 * 
	 * @param sql 传进来的sql语句  类似于：insert into table (tableName) values (?)
	 * @param params 参数   类似与：new Object []{"参数1","参数2","参数3","参数4","参数5",...}
	 * @param firstRow 分页的起始行
	 * @param pageCount  分页的每页的条数
	 * @param clazz   查询的数据需要封装到那个类中  传递类的字节码就好了
	 * @return  返回的是一个对象型的list集合   对象 = clazz
	 */
	@SuppressWarnings("unchecked")
	public static List getEntityDatas(String sql,Object[] params,Integer firstRow,Integer pageCount,Class clazz){
		Connection conn = null;
		PreparedStatement ps = null;
		ResultSet rs = null;

		List entityList= new ArrayList();
		
		if(null != firstRow && null != pageCount && firstRow >= 0 && pageCount >= 1){
			sql = sql + " limit " + firstRow + "," + pageCount;
		}
		//编译sql
		try {
			// 连接数据库
			conn = DBUtils.getConnection();
			ps = conn.prepareStatement(sql);
			for (int i = 0; i < params.length; i++) {
				ps.setObject(i+1, params[i]);
			}
			
			// 取到的元数据 （列名）
			ResultSetMetaData metaData = ps.getMetaData();
			int columnCount = metaData.getColumnCount();
			
			rs = ps.executeQuery();
			
			//"select empId,empName,password,empAge from employee where empId = ? and empName = ? group by empName HAVING AVG(empAge) > ? limit ?,?  ";
			Field declaredField = null;
			while(rs.next()){
				
				// 拿到实体类对象
				Object obj = clazz.newInstance();
				for (int i = 1; i <= columnCount; i++) {
					//  取到的是数据库的列名
					String columnName = metaData.getColumnName(i);
					// 取到的是sql中的别名
					//String columnLabel = metaData.getColumnLabel(i);
					
					//  解析 数据库字段名称   拼凑成相应的实体类的某一属性
					String[] columnSplit = columnName.split("_");
					String entityName = "";
					entityName += columnSplit[0]; //"emp"
					for (int j = 0; j < columnSplit.length; j++) {
						if(j > 0){ // "id"
							entityName += columnSplit[j].substring(0, 1).toUpperCase() + columnSplit[j].substring(1);
						}
					}
					
					//  entityName  告诉declaredField 我们需要obj对象的哪一个属性 为下一步做准备
					try {
						declaredField = clazz.getDeclaredField(entityName);
					} catch (NoSuchFieldException | SecurityException e) {
						System.out.println("警告" + entityName + "  属性获取不到！！请核实！！");
						//e.printStackTrace();
						continue;
					}
					
					// 属性需要公开   所修改一下权限
					declaredField.setAccessible(true);
					
					//  将rs.getObject(i) 值给 obj实体类的对应的属性
					declaredField.set(obj, rs.getObject(i));
					
				}
				entityList.add(obj);
			}
			
		} catch (SQLException e) {
			e.printStackTrace();
		} catch (InstantiationException | IllegalAccessException e1) {
			System.out.println("属性获取失败！！");
			e1.printStackTrace();
		}finally{
			DBUtils.close(conn, ps, rs);
		}
		return entityList;
	}
	
	public static List getEntityDatas(String sql,Object[] params,Class clazz){
		return DBHelper.getEntityDatas(sql, params, null, null,clazz);
	}
}
